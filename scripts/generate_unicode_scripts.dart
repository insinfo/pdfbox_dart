import 'dart:convert';
import 'dart:io';

class _Range {
  _Range(this.start, this.end, this.script);

  int start;
  int end;
  final String script;
}

Future<void> main() async {
  final sourcePath =
      'pdfbox-java/fontbox/src/main/resources/org/apache/fontbox/unicode/Scripts.txt';
  final sourceFile = File(sourcePath);
  if (!sourceFile.existsSync()) {
    stderr.writeln('Source file not found: $sourcePath');
    exitCode = 66; // EX_NOINPUT
    return;
  }

  final ranges = <_Range>[];
  final lines = await sourceFile.readAsLines(encoding: utf8);
  for (final rawLine in lines) {
    var line = rawLine;
    final hash = line.indexOf('#');
    if (hash != -1) {
      line = line.substring(0, hash);
    }
    line = line.trim();
    if (line.isEmpty) {
      continue;
    }
    final semi = line.indexOf(';');
    if (semi == -1) {
      continue;
    }
    final rangePart = line.substring(0, semi).trim();
    final scriptPart = line.substring(semi + 1).trim();
    final script = scriptPart.split(RegExp(r'\s+')).first;

    final dots = rangePart.indexOf('..');
    final start = int.parse(
        dots == -1 ? rangePart : rangePart.substring(0, dots),
        radix: 16);
    final end = int.parse(
        dots == -1 ? rangePart : rangePart.substring(dots + 2),
        radix: 16);

    if (ranges.isNotEmpty) {
      final last = ranges.last;
      if (last.end + 1 == start && last.script == script) {
        last.end = end;
        continue;
      }
    }
    ranges.add(_Range(start, end, script));
  }

  if (ranges.isEmpty) {
    stderr.writeln('No ranges parsed from $sourcePath');
    exitCode = 65; // EX_DATAERR
    return;
  }

  ranges.sort((a, b) => a.start.compareTo(b.start));

  final merged = <_Range>[];
  for (final range in ranges) {
    if (merged.isEmpty) {
      merged.add(range);
      continue;
    }
    final last = merged.last;
    if (last.end >= range.start) {
      throw StateError(
        'Overlapping ranges detected: '
        '0x${last.start.toRadixString(16)}-0x${last.end.toRadixString(16)} and '
        '0x${range.start.toRadixString(16)}-0x${range.end.toRadixString(16)}',
      );
    }
    if (last.end + 1 == range.start && last.script == range.script) {
      last.end = range.end;
      continue;
    }
    merged.add(range);
  }

  final outputRanges = merged;

  final buffer = StringBuffer();
  buffer.writeln('// GENERATED CODE - DO NOT MODIFY BY HAND.');
  buffer.writeln('// Generated by scripts/generate_unicode_scripts.dart');
  buffer.writeln("const List<int> unicodeRangeStarts = <int>[");
  _writeIntList(buffer, outputRanges.map((r) => r.start));
  buffer.writeln('];');
  buffer.writeln();
  buffer.writeln('const List<int> unicodeRangeEnds = <int>[');
  _writeIntList(buffer, outputRanges.map((r) => r.end));
  buffer.writeln('];');
  buffer.writeln();
  buffer.writeln('const List<String> unicodeRangeScripts = <String>[');
  _writeStringList(buffer, outputRanges.map((r) => r.script));
  buffer.writeln('];');

  final outputPath = 'lib/src/fontbox/ttf/data/unicode_scripts_data.dart';
  final outputFile = File(outputPath);
  await outputFile.parent.create(recursive: true);
  await outputFile.writeAsString(buffer.toString());
  stdout.writeln('Wrote ${outputRanges.length} ranges to $outputPath');
}

void _writeIntList(StringBuffer buffer, Iterable<int> values) {
  final list = values.toList();
  for (var i = 0; i < list.length; i++) {
    if (i % 8 == 0) {
      buffer.write('  ');
    }
    final value = list[i];
    buffer.write('0x${value.toRadixString(16).toUpperCase().padLeft(4, '0')}');
    final isLast = i == list.length - 1;
    if (isLast) {
      buffer.writeln();
    } else if ((i + 1) % 8 == 0) {
      buffer.writeln(',');
    } else {
      buffer.write(', ');
    }
  }
}

void _writeStringList(StringBuffer buffer, Iterable<String> values) {
  final list = values.toList();
  for (var i = 0; i < list.length; i++) {
    if (i % 6 == 0) {
      buffer.write('  ');
    }
    final value = list[i].replaceAll("'", "\\'");
    buffer.write("'$value'");
    final isLast = i == list.length - 1;
    if (isLast) {
      buffer.writeln();
    } else if ((i + 1) % 6 == 0) {
      buffer.writeln(',');
    } else {
      buffer.write(', ');
    }
  }
}
